{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SlimFlow Documentation","text":"<p>SlimFlow is a small Python module that makes running and processing SLiM simulations with Snakemake much easier. It will also work with msprime, though this is currently in development. I've used this module for several projects (e.g. Buffalo and Coop 2020, Buffalo and Kern 2024), and split it out so others can use. </p> <p>SlimFlow takes a simple YAML configuration file of simulation parameters and generates all possible parameter combinations with their replicates, and uniquely seeds each one, creating a list of filepath targets. SlimFlow also handles (1) creating the filepath templates, which maps simulation parameters to Snakemake wildcards, and (2) passing parameters to SLiM through the command line. The end result is that fairly complicated simulations can be created and executed via Snakemake with very little boilerplate code. Below is an example of running some BGS simulations according to the arbitrary parameters specified in a YAML file:</p> <pre><code>from slimflow import GridRuns\n\nif not len(config):\n  raise ValueError(\"config file not specified, use --configfile &lt;config&gt;.yml\")\n\nrun = GridRuns(config)\n\n# generate all the targets for this YAML file.\nall_sims = run.generate_targets()\n\n# a simple, small amount of boilerplate code will run all simulations.\nrule slim:\n  input: run.script, **run.input\n  output: **run.output_template()\n  shell: run.slim_cmd()\n\nrule all:\n  input: all_sims['filepath']\n</code></pre> <p>The <code>GridRuns</code> class is designed to generate the output files in a well-organized fashion, in a tidy readable directory structure that is easy  to process like:</p> <pre><code>&lt;name&gt;/&lt;dir&gt;/&lt;key1__val1&gt;/&lt;key2__val1&gt;/rep_&lt;rep&gt;__seed_&lt;seed&gt;__&lt;suffix&gt;\n</code></pre> <p>Here is a concrete example of a file structure from the BGS simulation example in <code>examples/bgs</code>.</p> <pre><code>$ tree runs\nruns\n\u2514\u2500\u2500 bgs\n    \u2514\u2500\u2500 N__1000\n        \u251c\u2500\u2500 mu__1e-08\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 sh__0.01\n        \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rbp__1e-08\n        \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 rep_0__seed_7919168045412322065__log.tsv.gz\n        \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 rep_0__seed_7919168045412322065__summary.tsv\n        \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 rep_0__seed_7919168045412322065__treeseq.tree\n        \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 rep_1__seed_7919168045412322066__log.tsv.gz\n        \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 rep_1__seed_7919168045412322066__summary.tsv\n        \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 rep_1__seed_7919168045412322066__treeseq.tree\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 sh__0.1\n        \u2502\u00a0\u00a0     \u2514\u2500\u2500 rbp__1e-08\n        \u2502\u00a0\u00a0         \u251c\u2500\u2500 rep_0__seed_6432084778622665797__log.tsv.gz\n        \u2502\u00a0\u00a0         \u251c\u2500\u2500 rep_0__seed_6432084778622665797__summary.tsv\n[...]\n</code></pre> <p>SlimFlow generates all combinations of the variables, and creates sequential random seeds per parameter combination for each seed. This way, if more replicates are added, they do alter the state of the pseudorandom number generator, which would trigger a bunch of unnecessary simulations.</p> <p>SlimFlow is designed to simplify writing Snakemake rules for running such SLiM simulations. It will automatically generate list of target files (e.g. the resulting files of a simulation) for all parameter combinations and replicates, as well as target templates which wildcard templates that match the file pattern template of these target files. This may seem abstract, but it eliminates a great deal of boilerplate Snakemake stuff.</p>"},{"location":"#example","title":"Example","text":"<p>The best way to see how SlimFlow works is through a simple example; the full source of the example is in <code>examples/bgs</code>. Suppose you want to run some background selection simulation with a SLiM file <code>bgs.slim</code>, across several different combinations of parameters and independent replicates with different seeds. </p>"},{"location":"#yaml-simulation-parameter-configuration","title":"YAML Simulation Parameter Configuration","text":"<p>First, we would write a YAML config file for this simulation \"run\" that looks like:</p> <pre><code>---\nname: bgs\nscript: bgs.slim\ndir: runs\nnreps: 2\nseed: 42\nsuffices:\n  treeseq_file: treeseq.tree\n  log_file: log.tsv.gz\nvariables:\n  N:\n  - 1000\n  mu:\n  - 2.0e-08\n  - 1.0e-08\n  sh:\n  - 0.01\n  - 0.1\n  rbp:\n  - 1.0e-08\n</code></pre> <p>This specifies the key bits of a bunch of simulation runs: the master <code>seed</code>, the number of replicates (<code>nreps</code>), the simulation results directory (<code>dir</code>), and most importantly, the parameters variables that are passed to the SLiM simulation as command line arguments.</p> <p>In some cases, simulations have multiple output files, such as a tree sequence <code>.tree</code> file, as well as a <code>.tsv.gz</code> log file. SlimFlow supports that through different suffices that will have the same output filename, but different suffices. This common filename up to the suffix allows them to be paired in downstream analyses. </p>"},{"location":"#generating-simulation-targets","title":"Generating Simulation Targets","text":"<p>Then, using SlimFlow, we can load in the config YAML file:</p> <pre><code>&gt;&gt;&gt; import yaml\n&gt;&gt;&gt; from slimflow import GridRuns\n&gt;&gt;&gt; config = yaml.safe_load(open('examples/bgs/bgs_config.yml'))\n&gt;&gt;&gt; run = GridRuns(config)\n&gt;&gt;&gt; run\nGridRuns(bgs):\nNumber of parameter combinations (\ud835\udc58): 4\nNumber of replicates (\ud835\udc5b): 2\nTotal simulations (\ud835\udc58 \u00d7 \ud835\udc5b): 8\nVariables:\n  N \u2208 {1000}\n  mu \u2208 {2e-08, 1e-08}\n  sh \u2208 {0.01, 0.1}\n  rbp \u2208 {1e-08}\n</code></pre> <p>All simulation run output files (i.e. \"targets\") can be generated with <code>GridRuns.generate_targets()</code>. This method just generates all parameter combinations and seeds them, creating the seeded filename which looks like <code>rep_0__seed_7138484576005690179__&lt;suffix&gt;</code>. The suffices for simulation output files (e.g. <code>treeseq.tree</code> or <code>log.tsv.gz</code>) are defined in the YAML configuration file; these are the files expected to result from each SLiM simulation.</p> <p>All the results are stored in Polars dataframe, which contain a <code>filepath</code> column to each simulation file, as well as each parameter combination. Here's the first few rows and a selection of columns:</p> <pre><code>&gt;&gt;&gt; run.generate_targets().select(['N', 'mu', 'sh', 'filepath']).head(2)\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 N    \u2506 mu        \u2506 sh   \u2506 filepath                          \u2502\n\u2502 ---  \u2506 ---       \u2506 ---  \u2506 ---                               \u2502\n\u2502 i64  \u2506 f64       \u2506 f64  \u2506 str                               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1000 \u2506 2.0000e-8 \u2506 0.01 \u2506 runs/bgs/N__1000/mu__2e-08/sh__0\u2026 \u2502\n\u2502 1000 \u2506 2.0000e-8 \u2506 0.01 \u2506 runs/bgs/N__1000/mu__2e-08/sh__0\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This dataframe can then be used to join in results during downstream processing. Here is an example of generating target files with the default suffices:</p> <pre><code>&gt;&gt;&gt; targets = run.generate_targets()\n# targets were generated for both suffices for this simulation replicate:\n&gt;&gt;&gt; targets[0]\n'runs/region/N__1000/mu__2e-08/sh__0.01/rbp__1e-08/rep0_seed7138484576005690179_treeseq.tree'\n&gt;&gt;&gt; targets[1]\n'runs/region/N__1000/mu__2e-08/sh__0.01/rbp__1e-08/rep0_seed7138484576005690179_log.tsv.gz'\n</code></pre>"},{"location":"#generating-snakefile-inputoutput-templates","title":"Generating Snakefile Input/Output Templates","text":"<p>Additionally, SlimFlow generates a dictionary containing the filename tempate, or pattern with wildcards that are matched by rules so parameters can flow into the <code>run</code> or <code>shell</code> directives.</p> <p>These templates can be directly used in a Snakefile rule's <code>input</code> and <code>output</code> blocks:</p> <pre><code>&gt;&gt;&gt; print(run.output_template())\n{'treeseq_file': 'runs/region/N__{N}/mu__{mu}/sh__{sh}/rbp__{rbp}/rep{rep}_seed{seed}_treeseq.tree', \n 'log_file': 'runs/region/N__{N}/mu__{mu}/sh__{sh}/rbp__{rbp}/rep{rep}_seed{seed}_log.tsv.gz'} \n</code></pre> <p>Note that suffices are stored in dictionaries so that multiple input/output files could be used with rules. These dictionaries are unpacked with the <code>**</code> before run into <code>key=value</code> arguments for <code>input</code>/<code>output</code>.</p> <p>Both <code>GridRuns.generate_targets()</code> and <code>GridRuns.output_template()</code> can also create target files with different suffices and parent output directories (i.e. like <code>runs</code> in the example config). This is to make downstream analyses easier: for example, if one Snakemake rule needed to take in tree sequences and add mutations, it could use <code>input: **run.output_template(suffices={'tree': 'treeseq.tree'})</code> and <code>output: **run.output_template(suffices={'tree': 'mutations.tree'})</code> to create these target templates. Similarly, all of the target files could be created with <code>run.generate_targets(suffices={'tree': 'mutations.tree'})</code>. </p>"},{"location":"#generation-of-slim-commands-for-snakemake-rules","title":"Generation of SLiM Commands for Snakemake Rules","text":"<p>SlimFlow also generates the SLiM command string used to pass in the parameter arguments as wildcards:</p> <pre><code>&gt;&gt;&gt; print(run.slim_cmd())\nslim -d N={wildcards.N} -d mu={wildcards.mu} -d sh={wildcards.sh} -d rbp={wildcards.rbp} -s {wildcards.seed} -d rep={wildcards.rep} -d \"treeseq_file='{output.treeseq_file}'\" -d \"log_file='{output.log_file}'\" -d name=\\\\\"region\\\\\" region.slim\n</code></pre> <p>These wildcards for each parameter match the free variables in the YAML configuration file and the SliM command.</p>"},{"location":"#using-slimflow-in-a-snakefile","title":"Using SlimFlow in a Snakefile","text":"<p>Then, using these components (the generated targets, target template, and the SLiM command with wildcards), we can run easily write a Snakefile that runs our simulations:</p> <pre><code>from slimflow import GridRuns\n\nif not len(config):\n  raise ValueError(\"config file not specified, use --configfile &lt;config&gt;.yml\")\n\nrun = GridRuns(config)\n\n# generate all the targets for this YAML file.\nall_sims = run.generate_targets()\n\n# a simple, small amount of boilerplate code will run all simulations.\nrule slim:\n  input: run.script, **run.input\n  output: **run.output_template()\n  shell: run.slim_cmd()\n\nrule all:\n  input: all_sims['filepath']\n</code></pre>"},{"location":"#working-downstream-of-simulation-results","title":"Working Downstream of Simulation Results","text":"<p>Often, we need to process simulation results in downstream analyses. <code>GridRuns.output_template()</code> can be used to generate the input and output of Snakefile rules for these downstream analyses. </p>"},{"location":"api/gridruns/","title":"GridRuns","text":"<p><code>GridRuns</code> is a class to aid in setting up multiple simulations across a grid (Cartesian product) of parameter combinations. It will translate a YAML file like this:</p> <pre><code>---\nname: bgs\nscript: bgs.slim\ndir: runs\nnreps: 2\nseed: 42\nsuffices:\n  treeseq_file: treeseq.tree\n  log_file: log.tsv.gz\nvariables:\n  N:\n  - 1000\n  mu:\n  - 2.0e-08\n  - 1.0e-08\n  sh:\n  - 0.01\n  - 0.1\n  rbp:\n  - 1.0e-08\n</code></pre> <p>Into an object containing this information, that can be used to generate SLiM targets, etc. Let's look at the loading a YAML config file into a set of simulation parameters:</p> <pre><code>&gt;&gt;&gt; import yaml\n&gt;&gt;&gt; from slimflow import GridRuns\n&gt;&gt;&gt; config = yaml.safe_load(open('tests/data/test_config.yml'))\n&gt;&gt;&gt; run = GridRuns(config)\n&gt;&gt;&gt; run\nGridRuns(bgs):\nNumber of parameter combinations (\ud835\udc58): 4\nNumber of replicates (\ud835\udc5b): 2\nTotal simulations (\ud835\udc58 \u00d7 \ud835\udc5b): 8\nVariables:\n  N \u2208 {1000}\n  mu \u2208 {2e-08, 1e-08}\n  sh \u2208 {0.01, 0.1}\n  rbp \u2208 {1e-08}\n\n\n&gt;&gt;&gt; run.generate_targets().select(['N', 'mu', 'sh', 'filepath']).head(2)\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 N    \u2506 mu        \u2506 sh   \u2506 filepath                          \u2502\n\u2502 ---  \u2506 ---       \u2506 ---  \u2506 ---                               \u2502\n\u2502 i64  \u2506 f64       \u2506 f64  \u2506 str                               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1000 \u2506 2.0000e-8 \u2506 0.01 \u2506 runs/bgs/N__1000/mu__2e-08/sh__0\u2026 \u2502\n\u2502 1000 \u2506 2.0000e-8 \u2506 0.01 \u2506 runs/bgs/N__1000/mu__2e-08/sh__0\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; targets = run.generate_targets()\n\n&gt;&gt;&gt; targets.columns\n['key', 'N', 'mu', 'sh', 'rbp', 'filepath', 'filename', 'rep', 'seed', 'suffix']\n\n# targets were generated for both suffices for this simulation replicate:\n&gt;&gt;&gt; targets['filepath'][0]\n'runs/bgs/N__1000/mu__2e-08/sh__0.01/rbp__1e-08/rep_0__seed_7138484576005612783__treeseq.tree'\n&gt;&gt;&gt; targets['filepath'][1]\n'runs/bgs/N__1000/mu__2e-08/sh__0.01/rbp__1e-08/rep_0__seed_7138484576005612783__log.tsv.gz'\n\n# slimflow also generates the proper SLiM command line call to pass\n# these parameters in:\n&gt;&gt;&gt; print(run.slim_cmd())  # doctest: +ELLIPSIS\nslim -d N={wildcards.N} -d mu={wildcards.mu} -d sh={wildcards.sh}...bgs.slim\n\n&gt;&gt;&gt; print(run.target_template())  # doctest: +ELLIPSIS\n{'treeseq_file': 'runs/bgs/N__{N}/mu__{mu}/sh__{sh}/...}\n\n&gt;&gt;&gt; print(run.target_template(outdir='processed', suffices={'tsv': '.tsv'},                                  filename='results'))\n{'tsv': 'runs/bgs/processed/N__{N}/mu__{mu}/sh__{sh}/.../results.tsv'}\n</code></pre> <p>This class uses a fairly general YAML format to store simulations in a way where they can be quickly found if needed. The format used is:</p> <p>This is the parameter-to-directory scheme, and it puts some mild constraints on what can be a free parameter (e.g., we can't have file paths become the name of a subdirectory).</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration dictionary for the SLiM runs.</p> required <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>The configuration dictionary for the SLiM runs.</p> <code>name</code> <code>str</code> <p>The main run name, which should be unique to the fixed                 parameters.</p> <code>script</code> <code>str</code> <p>The path to the SLiM script.</p> <code>seed</code> <code>int</code> <p>The random seed value.</p> <code>rng</code> <code>Generator</code> <p>The random number generator object.</p> <code>dir</code> <code>str</code> <p>The base directory to store the simulations.</p> <code>suffices</code> <code>dict</code> <p>A dictionary of suffices for the output files.</p> <code>fixed</code> <code>dict</code> <p>The parameters that do not change across the simulations.</p> <code>input</code> <code>dict</code> <p>The input files that are also fixed but will trigger a           re-run.</p> <code>variable</code> <code>dict</code> <p>The parameters that vary across simulations.</p> <code>nreps</code> <code>int</code> <p>The number of repetitions for each parameter combination.</p> <code>basedir</code> <code>str</code> <p>The base directory path for the simulations.</p> <code>simdir</code> <code>str</code> <p>The directory path for storing the simulation results.</p>"},{"location":"api/gridruns/#slimflow.GridRuns.generate_targets","title":"<code>generate_targets(suffices=None, filename=None, outdir=None, nreps=None, create=True)</code>","text":"<p>Generate all the target filenames for the SLiM runs.</p> <p>Parameters:</p> Name Type Description Default <code>suffices</code> <code>dict</code> <p>A dictionary of suffices for the output             files. If not provided, the suffices from the config will be used.</p> <code>None</code> <code>filename</code> <code>str</code> <p>A filename for a particular parameter             combinations. If <code>None</code> (the defualt), the filename will be the             automatically-generated filename containing the seed and replicate            number. Specifying the filename will drop these per-replicate bits            of information, which is useful when multiple replicates are to be            processed together and the results output to a single file.</p> <code>None</code> <code>outdir</code> <code>str</code> <p>The output directory path. If not                     provided, the simulation directory will be used.</p> <code>None</code> <code>nreps</code> <code>int</code> <p>The number of repetitions for each                     parameter combination. If not provided, the value                     from the config will be used.</p> <code>None</code> <code>create</code> <code>bool</code> <p>Whether to create the directories if                     they don't exist. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>A list of target filenames.</p>"},{"location":"api/gridruns/#slimflow.GridRuns.slim_cmd","title":"<code>slim_cmd()</code>","text":"<p>Generate the SLiM command for running the simulations.</p> <p>Fixed parameters, input files, and the name are passed directly to the SLiM call here and are not part of the wildcards.</p> <p>Returns:</p> Type Description <p>The SLiM command.</p>"},{"location":"examples/bgs/","title":"Background Selection Example","text":"<p>This is the documentation for the example in <code>examples/bgs</code> \u2014 see the full example code on GitHub.</p>"},{"location":"examples/bgs/#the-yaml-configuration-file","title":"The YAML Configuration File","text":"<p>This is the configuration YAML file for the example:</p> <pre><code>---\nname: bgs\nscript: bgs.slim\ndir: runs\nnreps: 100\nseed: 42\nsuffices:\n  treeseq_file: treeseq.tree\n  log_file: log.tsv.gz\nvariables:\n  N:\n  - 1000\n  mu:\n  - 2.0e-08\n  - 1.0e-08\n  - 2.0e-09\n  - 1.0e-09\n  sh:\n  - 0.0001\n  - 0.001\n  - 0.01\n  - 0.1\n  rbp:\n  - 1.0e-08\n</code></pre>"},{"location":"examples/bgs/#the-snakefile","title":"The Snakefile","text":"<p>Below is the full Snakefile.</p> <pre><code>from slimflow import GridRuns\nimport numpy as np\nimport polars as pl\nimport tskit\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\n\nif not len(config):\n    raise ValueError(\"config file not specified on command line, use --configfile config.json\")\n\nrun = GridRuns(config)\n\n# Generate all the targets for this YAML file.\nsims_df = run.generate_targets()\n\n# The SLiM rule: a simple, small amount of boilerplate code will run all\n# simulations.\nrule slim:\n  input: run.script, **run.input\n  output: **run.target_template()\n  shell: run.slim_cmd()\n\n# Now suppose we wanted to calculate some statistic(s) *per* output file (this\n# could combine them too). We just need to map the *target template* from one\n# suffix to another. Note that this can be done in parallel easily, which is\n# useful for more computational tasks like adding mutations to trees.\nrule post_process:\n  input: run.script, **run.target_template(suffices={'tree': 'treeseq.tree'})\n  output: **run.target_template(suffices={'summary': 'summary.tsv'})\n  run:\n    # load the tree file\n    tree = tskit.load(input['tree'])\n\n    # calculate windowed diversity\n    windows = np.arange(0, tree.sequence_length+1, 10000)\n    pi = tree.diversity(mode='branch', windows=windows)\n\n    # output results\n    midpoint = (windows[1:] + windows[:-1])/2\n    pi_df = pl.DataFrame(dict(midpoint=midpoint, pi=pi))\n    pi_df.write_csv(output['summary'], separator=\"\\t\")\n\n\n# Dataframe of summary file targets.\nsummary_df = run.generate_targets(suffices={'summary': 'summary.tsv'})\n\n# The rule for summarizing all the results.\nrule process:\n  input: summary_df['filepath']\n  output: \"summary.tsv\"\n  run:\n    # If this rule runs, then all summary targets have been created.\n    assert len(input) == summary_df.shape[0]\n\n    # Load in all diversity summary dataframes.\n    dfs = [pl.read_csv(f, separator='\\t').with_columns(pl.lit(f).alias(\"filepath\"))\n                 for f in input]\n    df = pl.concat(dfs)\n\n    # Join in keys based on filepath - this brings in parameters.\n    df = df.join(summary_df.select(pl.exclude('suffix')), \n                 left_on='filepath', right_on='filepath', how='inner')\n\n    # A toy summarization example: take mean diversity.\n    df = df.groupby('key').mean().select(pl.exclude(['rep', 'seed', 'filename']))\n\n    # Write output.\n    df.write_csv(output[0], separator='\\t')\n\n\n# Create a figure from the summarized results.\nrule figure:\n  input: \"summary.tsv\"\n  output: \"figure.pdf\"\n  run:\n    d = pl.read_csv(input[0], separator='\\t')\n    fig, ax = plt.subplots()\n    ax.scatter(d['mu'] / d['sh'], d['pi']/ (4*d['N']))\n    ax.semilogx()\n    ax.set_ylabel('B')\n    ax.set_xlabel('$\\\\mu/s$')\n    fig.savefig(output[0])\n\nrule all:\n  input: sims_df['filepath'], \"figure.pdf\"\n</code></pre>"},{"location":"examples/bgs/#the-slim-script","title":"The SLiM Script","text":"<p>The BGS simulation (in a region with fixed recombination) SLiM script is:</p> <pre><code>  defineConstant(\"region_length\", 100000);\n  initializeTreeSeq();\n  defineConstant(\"seed\", getSeed());\n  initializeMutationRate(mu);\n\n  // We fix h = 0.5 and calculate the proper homozygous selection\n  // coefficient.\n  defineConstant(\"h\", 0.5);\n  defineConstant(\"s\", sh / h);\n\n  initializeMutationType(\"m1\", h, \"f\", -s);\n  initializeGenomicElementType(\"g1\", m1, 1.0);\n  initializeGenomicElement(g1, 0, region_length-1);\n  initializeRecombinationRate(rbp);\n  m1.convertToSubstitution = T;\n  m1.mutationStackPolicy = \"f\";\n\n  // create and set the metadata, which we output too\n  // for easier downstream processing.\n  defineConstant(\"metadata\", Dictionary());\n  defineConstant(\"burnin\", 10*N);\n\n  metadata.setValue(\"rep\", rep);\n  metadata.setValue(\"N\", N);\n  metadata.setValue(\"sh\", sh);\n  metadata.setValue(\"s\", s);\n  metadata.setValue(\"h\", h);\n  metadata.setValue(\"U\", mu*region_length);\n  metadata.setValue(\"mu\", mu);\n  metadata.setValue(\"rbp\", rbp);\n  metadata.setValue(\"region_length\", region_length);\n\n}\n\n1 early() {\n  sim.addSubpop(\"p1\", N);\n  community.rescheduleScriptBlock(s1, start=2, end=burnin);\n  community.rescheduleScriptBlock(s2, start=burnin, end=burnin);\n\n  // Log Files\n  log = community.createLogFile(log_file, compress=T, sep=\"\\t\", logInterval=10);\n  log.addCycle();\n  log.addMeanSDColumns('k', 'sim.subpopulations.individuals.countOfMutationsOfType(m1);');\n}\n\n\ns1 early() {\n  if (sim.cycle % 1000 == 0) \n    print(sim.cycle);\n}\n\ns2 late() {\n  sim.treeSeqOutput(treeseq_file, metadata=metadata);\n}\n</code></pre>"}]}